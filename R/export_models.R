#' Create C++ code to export \pkg{TMB} models from package.
#'
#' @param pkg Character string: any subdirectory of the package source code.
#' @param model_files Character vector of header files relative to \code{src/TMB} listing the \pkg{TMB} models to export.  If missing defaults to all \code{hpp} files in \code{src/TMB}.  \strong{Note:} Always use forward slash "/" to separate directories, even on Windows.
#' @return Invisible; called for its side effects.
#'
#' @details \pkg{TMB} models should be saved as C++ header files of the form \code{src/TMB/*.hpp}, and written almost exactly as with usual \pkg{TMB} \code{*.cpp} models.  So for example, \code{src/TMB/ModelA.hpp} might be written as:
#' \preformatted{
#' // __DO NOT__ '#include <TMB.hpp>' as file is not include-guarded
#'
#' #undef TMB_OBJECTIVE_PTR
#' #define TMB_OBJECTIVE_PTR obj
#' template<class Type>
#' Type ModelA(objective_function<Type>* obj) {
#'   // _exactly_ the same code as for usual 'ModelA.cpp'
#' }
#' #undef TMB_OBJECTIVE_PTR
#' #define TMB_OBJECTIVE_PTR this
#' }
#' The function \code{TMB_export} creates a file \code{src/TMB/pkgname_TMBExports.cpp} containing a single \pkg{TMB} model object which dispatches the appropriate \code{ModelA.hpp}, \code{ModelB.hpp}, etc. using \code{if/else} statements.  At the \R level, the correct model is invoked from \code{TMB::MakeADFun} exactly as for a single \pkg{TMB} model, except the \code{data} list argument gets appended the value e.g., \code{model_name = "ModelA"}.
#' @export
export_models <- function(pkg = ".", model_files) {
  root <- .package_root(pkg)
  pkg_name <- read.dcf(file = file.path(root, "DESCRIPTION"),
                       fields = "Package")[1]
  tmb_path <- file.path(root, "src", "TMB")
  tmb_main <- file.path(tmb_path, paste0(pkg_name, "_TMBExports.cpp"))
  # if not TMB-generated don't overwrite
  if(file.exists(tmb_main)) {
    if(readLines(tmb_main)[1] != "// Generated by TMB: do not edit by hand") {
      stop("'src/TMB/", basename(tmb_main), "' exists and not generated by TMB.  Not overwritten.")
    }
  }
  # replace template values
  tmb_lines <- readLines(.template_file("TMBExports.cpp"))
  # package name
  tmb_lines <- gsub("@@pkg@@", pkg_name, tmb_lines)
  # include files
  if(missing(model_files)) {
    model_files <- list.files(path = tmb_path, pattern = "[.]hpp$",
                              ignore.case = TRUE)
  }
  incl_lines <- paste0('#include "', model_files, '"', collapse = '\n')
  tmb_lines <- sub("@@includes@@", incl_lines, tmb_lines)
  # if statements
  # model names: no path and no extension
  model_names <- sub(pattern = "(.*?)\\..*$",
                     replacement = "\\1", basename(model_files))
  if(length(model_names) > 0) {
    if_lines <- paste0('if(model_name == "', model_names, '") {\n',
                       '    return ', model_names, '(this);\n',
                       '  }', collapse = ' else ')
    if_lines <- paste0(if_lines, ' else {\n',
                      '    error("Unknown model_name.");\n  }')
  } else {
    if_lines <- '  error("Unknown model_name.");'
  }
  tmb_lines <- sub("@@switches@@", if_lines, tmb_lines)
  cat(tmb_lines, sep = "\n", file = tmb_main)
}

# find package root: basically copied from devtools
.package_root <- function(path = ".") {
  if(!is.character(path) || length(path) != 1) {
    stop("'path' must be a string.", call. = FALSE)
  }
  path <- sub("/*$", "", normalizePath(path, mustWork = FALSE))
  if(!file.exists(path)) {
    stop("Can't find '", path, "'.", call. = FALSE)
  }
  if(!file.info(path)$isdir) {
    stop("'", path, "' is not a directory.", call. = FALSE)
  }
  while(!file.exists(file.path(path, "DESCRIPTION"))) {
    path <- dirname(path)
    if(identical(path, dirname(path))) {
      stop("Could not find package root.", call. = FALSE)
    }
  }
  path
}

